# Xenon

[![CI](https://github.com/MarsZDF/xenon/actions/workflows/ci.yml/badge.svg)](https://github.com/MarsZDF/xenon/actions/workflows/ci.yml)



A robust, zero-dependency Python library for cleaning up malformed XML generated by Large Language Models (LLMs).



## üöÄ Why Xenon?







In the era of Large Language Models, applications increasingly rely on AI-generated **XML and XML-like structured data** (such as HTML or SVG). This data is often messy, malformed, or incomplete.







**Xenon is the essential bridge between AI-generated content and reliable application code, specialized for XML.**







It is a secure-by-default, zero-dependency library designed to be the fastest and most reliable way to sanitize, repair, and structure **XML and XML-like markup** from untrusted sources, making AI-generated output safe and usable for any application. Whether you're building a RAG pipeline, an agent-based system, or just processing LLM output, Xenon ensures your **XML data** is clean, correct, and secure.



## Features



- **üîí v1.0.0**: Secure-by-default with explicit trust levels, **enhanced XSS protection**, and optional schema/DTD validation (BREAKING CHANGES - see below)



- **Zero Dependencies**: Uses only Python Standard Library

- **Stack-based Parser**: Deterministic handling of nested structures and truncation
- **LLM-Focused**: Specifically designed to handle common LLM XML generation failures
- **Smart Tag Matching**: Detects and fixes typos in closing tags using similarity matching
- **Robust Error Handling**: Production-ready with comprehensive validation and error recovery
- **Multiple Modes**: Choose between strict, default, or lenient error handling
- **Simple Interface**: Easy-to-use functions with explicit security posture
- **üöÄ v0.7.0**: Real-time streaming repair for LLM token-by-token output (near-zero latency!)
- **üÜï v0.6.0**: Diff reporting, formatting, HTML entities, and encoding detection
- **v0.5.0**: Advanced XML compliance features and cleaner configuration API

## Installation

Install directly from GitHub:

```bash
pip install git+https://github.com/MarsZDF/xenon.git
```

Or clone and install locally:

```bash
git clone https://github.com/MarsZDF/xenon.git
cd xenon
pip install -e .
```

> **Note**: This package is not yet published to PyPI. Once published, you'll be able to install with `pip install xenon`.

## üîí v1.0.0: Secure-by-Default (BREAKING CHANGES)

**Version 1.0.0 introduces mandatory trust levels for security-conscious XML repair.**

### ‚ö†Ô∏è Breaking Changes

All core functions now **require** a `trust` parameter specifying the security posture:

```python
# ‚ùå OLD (v0.x) - No longer works
from xenon import repair_xml_safe
result = repair_xml_safe(llm_output)

# ‚úÖ NEW (v1.0.0) - Trust level required
from xenon import repair_xml_safe, TrustLevel
result = repair_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
```

### Trust Levels Explained

Choose the trust level based on your input source:

| Trust Level | Use For | Security Features | Performance |
|-------------|---------|-------------------|-------------|
| **`UNTRUSTED`** | LLM output, user uploads, external APIs | üîí All protections enabled, **Optional schema/DTD validation** | ~15-20% slower |
| **`INTERNAL`** | Internal services, config files, database exports | üîê Moderate protections | ~5% slower |
| **`TRUSTED`** | Hardcoded literals, test fixtures, known-good data | ‚ö° No security overhead | Fastest (baseline) |

```python
from xenon import repair_xml_safe, TrustLevel

# LLM output - maximum security
llm_xml = chatgpt_response.content
safe = repair_xml_safe(llm_xml, trust=TrustLevel.UNTRUSTED)
# Automatically strips: <?php ?>, <!DOCTYPE>, <script>, limits depth

# Internal microservice - balanced security
service_xml = internal_api_call()
result = repair_xml_safe(service_xml, trust=TrustLevel.INTERNAL)
# Strips: <!DOCTYPE> (defense in depth)

# Test fixture - no overhead
TEST_XML = '<root><item>test</item></root>'
repaired = repair_xml_safe(TEST_XML, trust=TrustLevel.TRUSTED)
# No security checks, fastest performance
```

### Migration Guide

**Step 1:** Add `TrustLevel` import
```python
from xenon import repair_xml_safe, TrustLevel  # Add TrustLevel
```

**Step 2:** Add `trust` parameter to all function calls

```python
# Before (v0.x)
repair_xml_safe(xml)
parse_xml_safe(xml)
batch_repair([xml1, xml2])
StreamingXMLRepair()

# After (v1.0.0)
repair_xml_safe(xml, trust=TrustLevel.UNTRUSTED)
parse_xml_safe(xml, trust=TrustLevel.UNTRUSTED)
batch_repair([xml1, xml2], trust=TrustLevel.UNTRUSTED)
StreamingXMLRepair(trust=TrustLevel.UNTRUSTED)
```

**Step 3:** Choose appropriate trust level
- **Default to `UNTRUSTED`** for safety
- Use `INTERNAL` only for internal services you control
- Use `TRUSTED` only for hardcoded test data

### What Changed Under the Hood

**UNTRUSTED** level automatically enables:
- ‚úÖ Strip dangerous processing instructions (PHP, ASP, JSP)
- ‚úÖ Strip external entities (XXE prevention)
- ‚úÖ Strip dangerous tags (script, iframe, object, embed)
- ‚úÖ Enhanced XSS protection (aggressive attribute and text node escaping)
- ‚úÖ Max depth limit: 1000 (DoS prevention)
- ‚úÖ Strict validation
- ‚úÖ Threat auditing
- ‚úÖ Schema validation (if schema provided)

**INTERNAL** level enables:
- ‚úÖ Strip external entities (defense in depth)
- ‚úÖ Max depth limit: 10000

**TRUSTED** level:
- ‚ö° All security checks disabled for maximum performance

### Why This Change?

**Security by default:** Making trust explicit forces developers to think about security at the point of use, preventing accidental exposure to injection attacks.

**Pit of success:** The new API makes it **harder to make insecure choices** and **easier to make secure ones**.

## ‚ö†Ô∏è Security Model

**Xenon is a syntactic repair tool with security guardrails, NOT a complete security sanitizer.**

**What Xenon DOES** (with appropriate trust levels):
- ‚úì Strip dangerous processing instructions (PHP, ASP, JSP)
- ‚úì Strip external entity declarations (XXE prevention)
- ‚úì Strip dangerous tags (script, iframe, object, embed)
- ‚úì Enhanced XSS Protection (aggressive attribute and text node escaping)
- ‚úì Limit nesting depth (DoS prevention)
- ‚úì Validate output structure

**What Xenon does NOT**:
- ‚úó Filter all malicious Unicode
- ‚úó Validate XML content semantics
- ‚úó Provide complete XSS protection
- ‚úó Sandbox execution environments

**For untrusted input:** Use `TrustLevel.UNTRUSTED` AND add application-level validation.

See [SECURITY.md](SECURITY.md) for detailed threat model and best practices.

## Quick Start

```python
from xenon import repair_xml_safe, parse_xml_safe, TrustLevel, ValidationError

# Repair malformed LLM output
llm_output = 'Sure, here is the XML: <root><user name=john'
repaired = repair_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
print(repaired)  # <root><user name="john"></user></root>

# Parse to dictionary
result = parse_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
print(result)    # {'root': {'user': {'@attributes': {'name': 'john'}}}}

# For test fixtures (no security overhead)
TEST_XML = '<root><item>test</item></root>'
repaired = repair_xml_safe(TEST_XML, trust=TrustLevel.TRUSTED)

# Example: Schema Validation
# Define a simple XSD schema
XSD_SCHEMA = """<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="root">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="item" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>"""

# Valid XML against schema
valid_xml = "<root><item>data</item></root>"
repaired_and_validated = repair_xml_safe(valid_xml, trust=TrustLevel.UNTRUSTED, schema_content=XSD_SCHEMA)
print(f"Valid XML after repair and validation: {repaired_and_validated}")

# Invalid XML against schema - will raise ValidationError
invalid_xml = "<root><wrong_item>data</wrong_item></root>"
try:
    repair_xml_safe(invalid_xml, trust=TrustLevel.UNTRUSTED, schema_content=XSD_SCHEMA)
except ValidationError as e:
    print(f"Caught validation error for invalid XML: {e}")
```

## What's New in v0.6.0 üÜï

### Diff/Patch Reporting
Understand exactly what changed during repair:

```python
from xenon import repair_xml_with_diff

result, report = repair_xml_with_diff('<root><item>test')

# Get unified diff
print(report.to_unified_diff())
# --- Original
# +++ Repaired
# @@ -1 +1 @@
# -<root><item>test
# +<root><item>test</item></root>

# Get HTML diff for visualization
html = report.to_html_diff()
with open('diff.html', 'w') as f:
    f.write(html)

# Get statistics
stats = report.get_diff_summary()
print(f"Lines added: {stats['lines_added']}")
print(f"Similarity: {stats['similarity_ratio']:.1%}")
```

### Analyzing Repairs
Understand what repairs were performed and why:

```python
from xenon import repair_xml_with_report, RepairType

result, report = repair_xml_with_report('<root><?php code?><item>test & data')

# Get human-readable summary
print(report.summary())
# Performed 3 repair(s):
#   - [dangerous_pi_stripped] Removed dangerous PI
#   - [unescaped_entity] Escaped & character
#   - [truncation] Added closing tags

# Check if repairs were needed
if report:  # Truthy if any repairs performed
    print(f"Made {len(report)} repairs")

# Analyze by repair type
for action in report.actions:
    print(f"Type: {action.repair_type.value}")
    print(f"Description: {action.description}")
    if action.before:
        print(f"Changed: '{action.before}' ‚Üí '{action.after}'")

# Group repairs by type
grouped = report.by_type()
for repair_type, actions in grouped.items():
    print(f"{repair_type.value}: {len(actions)} occurrences")

# Get detailed statistics
stats = report.statistics()
print(f"Total repairs: {stats['total_repairs']}")
print(f"Truncations fixed: {stats.get('truncation_count', 0)}")

# Check for security issues
if report.has_security_issues():
    print("‚ö†Ô∏è  Security repairs were performed - review input source")

# Export to JSON for logging/analysis
import json
json_data = json.dumps(report.to_dict(), indent=2)
```

**15 Repair Types:**
- `TRUNCATION` - Fixed incomplete XML
- `CONVERSATIONAL_FLUFF` - Removed non-XML text
- `UNESCAPED_ENTITY` - Escaped &, <, >
- `MALFORMED_ATTRIBUTE` - Fixed attribute syntax
- `CDATA_WRAPPED` - Wrapped code in CDATA
- `TAG_TYPO` / `TAG_CASE_MISMATCH` - Fixed tag issues
- `DANGEROUS_PI_STRIPPED` - Removed <?php ?>, etc.
- `DANGEROUS_TAG_STRIPPED` - Removed <script>, etc.
- `EXTERNAL_ENTITY_STRIPPED` - XXE prevention
- And more... (see [API Reference](docs/API_REFERENCE.md))

### Smart Formatting
Format XML output for readability:

```python
from xenon import format_xml

xml = '<root><item>test</item><another>data</another></root>'

# Pretty-print with indentation
pretty = format_xml(xml, style='pretty', indent='  ')
print(pretty)
# <root>
#   <item>test</item>
#   <another>data</another>
# </root>

# Minify for compact output
compact = format_xml(xml, style='minify')
# <root><item>test</item><another>data</another></root>

# One tag per line (compact)
result = format_xml(xml, style='compact')
```

### HTML Entity Support
Handle HTML entities from web-trained LLMs:

```python
from xenon import convert_html_entities, normalize_entities

# Convert HTML entities to numeric XML entities
text = "Price: &euro;50 &mdash; &copy;2024"
result = convert_html_entities(text)
# Result: "Price: &#8364;50 &#8212; &#169;2024"

# Normalize all entities
text = "&lt;test&gt; &copy;2024 &#169;2024"
result = normalize_entities(text, mode='numeric')
# Converts HTML entities, preserves XML entities
```

Supports 40+ common HTML entities: `&nbsp;`, `&copy;`, `&euro;`, `&mdash;`, `&ldquo;`, `&rarr;`, Greek letters, math symbols, and more.

### Encoding Detection
Auto-detect and normalize encodings:

```python
from xenon import detect_encoding, normalize_encoding

# Detect encoding from BOM or XML declaration
data = b'\xef\xbb\xbf<?xml version="1.0"?><root/>'
encoding, confidence = detect_encoding(data)
# ('utf-8-sig', 1.0)

# Normalize to UTF-8 with Unicode normalization
result = normalize_encoding(data, normalize_unicode=True)
# Returns: '<root/>' as normalized string
```

### üöÄ All v0.6.0 Features in One Call
Use all features together with the integrated `repair_xml_safe()`:

```python
from xenon import repair_xml_safe

# Bytes input + all v0.6.0 features in ONE call!
result = repair_xml_safe(
    b'<root><?php code?><p>&euro;50</p><item>data',  # Accepts bytes
    # v0.6.0 Features:
    format_output='pretty',         # Pretty-print output
    html_entities='numeric',        # Convert HTML entities
    normalize_unicode=True,         # Apply NFC normalization
    # Plus v0.5.0 security features:
    strip_dangerous_pis=True,       # Remove <?php ?>
    auto_wrap_cdata=True,           # Wrap code in CDATA
    strict=True                     # Validate output
)

print(result)
# <root>
#   <p>‚Ç¨50</p>
#   <item>data</item>
# </root>
```

### Utility Functions
Powerful utilities exposed in v0.6.0:

```python
from xenon import (
    batch_repair,              # Batch processing
    stream_repair,             # Streaming for large datasets
    validate_xml_structure,    # Lightweight validation
    extract_text_content,      # Extract text from XML
    decode_xml                 # Auto-detect encoding
)

# Batch repair with error handling
xml_batch = ['<root>test1', '<root>test2</root>', '<root>test3']
results = batch_repair(xml_batch, on_error='skip')
for xml, error in results:
    if error:
        print(f"Failed: {error}")
    else:
        print(f"Success: {xml}")

# Stream repair for huge datasets
def xml_generator():
    for i in range(10000):
        yield f'<item id="{i}">data{i}'

for repaired, error in stream_repair(xml_generator()):
    if not error:
        process(repaired)

# Validate structure before expensive operations
is_valid, issues = validate_xml_structure(xml)
if not is_valid:
    print(f"Issues found: {issues}")

# Extract plain text from XML
text = extract_text_content('<root><p>Hello</p><p>World</p></root>')
# 'HelloWorld'
```

### Enhanced Error Messages
Get precise error context with line/column information:

```python
from xenon import repair_xml_safe, get_line_column, get_context_snippet

xml = """<root>
    <item id=invalid>
        <name>Test</name>
    </item>
</root>"""

try:
    result = repair_xml_safe(xml, strict=True)
except Exception as e:
    # Exceptions now include line/column context
    print(f"Error at line {e.line}, column {e.column}")
    print(f"Context: {e.context}")
    # Error at line 2, column 15
    # Context: '...id=invalid>...'

# Or use helper functions
position = xml.find("invalid")
line, col = get_line_column(xml, position)
context = get_context_snippet(xml, position, max_length=40)
print(f"Found at line {line}, column {col}: {context}")
```

## What's New in v0.7.0 üöÄ

### Streaming XML Repair for Real-Time LLM Output
Process XML as it's being generated, **token-by-token**, for near-zero latency in RAG pipelines:

```python
from xenon.streaming import StreamingXMLRepair
from xenon import TrustLevel

# Context manager (recommended - auto-finalize)
with StreamingXMLRepair(trust=TrustLevel.UNTRUSTED) as repairer:
    for chunk in llm_stream():
        for safe_xml in repairer.feed(chunk):
            yield safe_xml  # ‚úÖ User sees output instantly!
    # finalize() called automatically - closes open tags

# Manual control
repairer = StreamingXMLRepair(trust=TrustLevel.UNTRUSTED)

# Feed chunks as they arrive
for chunk in ["<root><user na", "me=john>Hel", "lo</user>"]:
    for safe_xml in repairer.feed(chunk):
        print(safe_xml)
        # Output:
        # <root>
        # <user name="john">
        # Hello
        # </user>

# Finalize to close any open tags
for final_xml in repairer.finalize():
    print(final_xml)
    # Output:
    # </root>
```

**Note**: Currently sync-only. Async support planned for future release.

**Benefits:**
- ‚ö° **Near-zero latency**: Yields XML as tokens arrive, no waiting for completion
- üß† **Constant memory**: Small buffer (~200 bytes) vs full XML in memory
- üîß **Handles chunk boundaries**: Tags can be split across chunks
- üéØ **Strips conversational fluff**: Automatically discards text before first `<`
- üè≠ **Production-ready**: Repairs attributes, entities, and truncation
- üì¶ **Context manager support**: Auto-finalize prevents unclosed tags

**Perfect for:**
- LLM streaming responses in RAG/chat applications
- Real-time XML generation from agents
- Processing large XML files without loading into memory
- Any scenario where immediate feedback matters

**Example: ChatGPT-style streaming**
```python
from xenon.streaming import StreamingXMLRepair
from xenon import TrustLevel

def llm_stream():
    # Simulate LLM output with conversational fluff
    yield "Sure, here's the XML you requested:\n\n"
    yield "<response>"
    yield '<user id=123 name='
    yield 'john>Hello'
    yield "</user>"
    # Oops, LLM stopped generating!

with StreamingXMLRepair(trust=TrustLevel.UNTRUSTED) as repairer:
    for chunk in llm_stream():
        for safe_xml in repairer.feed(chunk):
            print(safe_xml, end='')
    # Auto-finalize adds missing </response>

# Output: <response><user id="123" name="john">Hello</user></response>
```

**Trade-offs vs Batch Mode:**
- ‚úÖ Streaming: Near-zero latency, constant memory
- ‚úÖ Batch: Typo detection with Levenshtein, lookahead
- Use streaming for real-time output, batch for complete documents

See [STREAMING_DESIGN.md](docs/STREAMING_DESIGN.md) for architecture details.

## What's New in v0.5.0

### New XML Compliance Features

```python
from xenon import repair_xml_safe

# 1. Fix invalid tag names (starts with number, contains spaces)
xml = '<123tag>data</123tag>'
result = repair_xml_safe(xml, sanitize_invalid_tags=True)
# Result: <tag_123tag>data</tag_123tag>

xml = '<tag with spaces>data</tag with spaces>'
result = repair_xml_safe(xml, sanitize_invalid_tags=True)
# Result: <tag_with_spaces>data</tag_with_spaces>

# 2. Fix invalid namespace syntax (multiple colons, etc.)
xml = '<bad::ns>data</bad::ns>'
result = repair_xml_safe(xml, fix_namespace_syntax=True)
# Result: <bad_ns>data</bad_ns>

xml = '<ns1:ns2:tag>data</ns1:ns2:tag>'
result = repair_xml_safe(xml, fix_namespace_syntax=True)
# Result: <ns1:ns2_tag>data</ns1:ns2_tag>

# 3. Wrap multiple root elements
xml = '<root1>data1</root1><root2>data2</root2>'
result = repair_xml_safe(xml, wrap_multiple_roots=True)
# Result: <document><root1>data1</root1><root2>data2</root2></document>

# 4. Auto-wrap code content in CDATA sections
xml = '<code>if (x < 5 && y > 10) { return true; }</code>'
result = repair_xml_safe(xml, auto_wrap_cdata=True)
# Result: <code><![CDATA[if (x < 5 && y > 10) { return true; }]]></code>
# Works with: code, script, pre, sql, xpath, regex, query, formula, expression

# 5. Improved entity escaping (no double-escaping!)
xml = '<root>&lt;already&gt; & new</root>'
result = repair_xml_safe(xml)
# Result: <root>&lt;already&gt; &amp; new</root>
# (preserves existing entities, escapes new ones)

# 6. Attribute value escaping
xml = '<root attr="value & more">text</root>'
result = repair_xml_safe(xml)
# Result: <root attr="value &amp; more">text</root>
```

### Cleaner Configuration API (Recommended)

**New in v0.5.0:** Use configuration objects for complex setups:

```python
from xenon import XMLRepairEngine, XMLRepairConfig, SecurityFlags, RepairFlags

# Old way (still works!)
engine = XMLRepairEngine(
    strip_dangerous_pis=True,
    strip_external_entities=True,
    sanitize_invalid_tags=True,
    fix_namespace_syntax=True
)

# New way (recommended for clarity)
config = XMLRepairConfig(
    security=SecurityFlags.STRIP_DANGEROUS_PIS | SecurityFlags.STRIP_EXTERNAL_ENTITIES,
    repair=RepairFlags.SANITIZE_INVALID_TAGS | RepairFlags.FIX_NAMESPACE_SYNTAX | RepairFlags.AUTO_WRAP_CDATA
)
engine = XMLRepairEngine(config)

# Both produce the same result!
result = engine.repair_xml(malformed_xml)
```

**Benefits:**
- Cleaner, more maintainable code
- Better IDE autocomplete
- Easier to see which features are enabled
- Groups related features logically

## Security Features

For untrusted input, use `repair_xml_safe()` with security flags:

```python
from xenon import repair_xml_safe

# Untrusted XML with potential security threats
untrusted_xml = '''<?php system("whoami"); ?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>
    <script>alert('XSS')</script>
    <data>clean content</data>
</root>'''

# Repair with all security features enabled
safe_xml = repair_xml_safe(
    untrusted_xml,
    strip_dangerous_pis=True,      # Remove PHP/ASP/JSP code
    strip_external_entities=True,   # Remove DOCTYPE with entities
    strip_dangerous_tags=True       # Remove script/iframe/object/embed tags
)

# Result: <root>alert('XSS')<data>clean content</data></root>
# - PHP code removed
# - DOCTYPE removed
# - <script> tags removed (content preserved)
```

**Important:** These features provide basic protection but are NOT a complete security solution. Always validate and sanitize untrusted input using additional security layers.

## Supported Failure Modes

### 1. Truncation/Cut-off
When LLMs run out of tokens mid-tag:
```python
malformed = '<root><user name="alice"'
repaired = repair_xml(malformed)
# Result: <root><user name="alice"></user></root>
```

### 2. Conversational Fluff
XML embedded in conversational text:
```python
malformed = 'Here is your XML data:\n<root><message>Hello</message></root>\nHope this helps!'
repaired = repair_xml(malformed)
# Result: <root><message>Hello</message></root>
```

### 3. Malformed Attributes
Missing quotes around attribute values:
```python
malformed = '<item id=123 type=product name=widget>'
repaired = repair_xml(malformed)
# Result: <item id="123" type="product" name="widget"></item>
```

### 4. Unescaped Entities
Unescaped `&` or `<` in text content:
```python
malformed = '<desc>Barnes & Noble sells books < $20</desc>'
repaired = repair_xml(malformed)
# Result: <desc>Barnes &amp; Noble sells books &lt; $20</desc>
```

### 5. Code Content (CDATA)
Automatically wrap code and special content in CDATA sections:
```python
malformed = '<code>function test() { return x && y; }</code>'
repaired = repair_xml(malformed)
# Result: <code><![CDATA[function test() { return x && y; }]]></code>
```

### 6. Mismatched Tag Case
Case-insensitive tag matching (uses opening tag's case):
```python
malformed = '<Root><Item>text</item></Root>'
repaired = repair_xml(malformed)
# Result: <Root><Item>text</Item></Root>
```

### 7. Mismatched Tag Names (Typos)
Detects and fixes typos in closing tags using similarity matching:
```python
malformed = '<user>John Doe</usr>'
repaired = repair_xml(malformed)
# Result: <user>John Doe</user>

# Also handles multiple typos
malformed = '<users><user>Alice</usr><user>Bob</user></usrs>'
repaired = repair_xml(malformed)
# Result: <users><user>Alice</user><user>Bob</user></users>
```

**How it works:**
- Uses Levenshtein distance to detect typos (up to 2 character differences)
- Matches closing tags to nearest opening tag on the stack
- Fast: O(m√ón) where m,n are tag name lengths (~10-20 chars)
- Zero dependencies: pure Python stdlib

### 8. Missing Namespace Declarations
Auto-inject common namespace declarations:
```python
malformed = '<soap:Envelope><soap:Body>test</soap:Body></soap:Envelope>'
repaired = repair_xml(malformed)
# Result: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
#         <soap:Body>test</soap:Body></soap:Envelope>
```

### 9. Duplicate Attributes
Remove duplicate attributes (keeps first occurrence):
```python
malformed = '<item id="1" name="foo" id="2">'
repaired = repair_xml(malformed)
# Result: <item id="1" name="foo"></item>
```

### 10. Invalid Tag Names üÜï
Fix XML tag names that violate XML specification:
```python
malformed = '<123illegal>data</123illegal>'
repaired = repair_xml_safe(malformed, sanitize_invalid_tags=True)
# Result: <tag_123illegal>data</tag_123illegal>

malformed = '<tag-with spaces>data</tag-with spaces>'
repaired = repair_xml_safe(malformed, sanitize_invalid_tags=True)
# Result: <tag-with_spaces>data</tag-with_spaces>
```

### 11. Invalid Namespace Syntax üÜï
Fix namespace syntax that violates XML specification:
```python
malformed = '<bad::ns>data</bad::ns>'
repaired = repair_xml_safe(malformed, fix_namespace_syntax=True)
# Result: <bad_ns>data</bad_ns>

malformed = '<ns1:ns2:tag>data</ns1:ns2:tag>'
repaired = repair_xml_safe(malformed, fix_namespace_syntax=True)
# Result: <ns1:ns2_tag>data</ns1:ns2_tag>
```

### 12. Multiple Root Elements üÜï
Wrap multiple root elements to create valid XML:
```python
malformed = '<root1>data1</root1><root2>data2</root2>'
repaired = repair_xml_safe(malformed, wrap_multiple_roots=True)
# Result: <document><root1>data1</root1><root2>data2</root2></document>
```

## Error Handling

Xenon provides three different modes for different use cases:

### Safe Mode (Recommended for Production)

Use `repair_xml_safe()` for robust error handling with helpful error messages:

```python
from xenon import repair_xml_safe, ValidationError

try:
    result = repair_xml_safe(llm_output)
except ValidationError as e:
    print(f"Invalid input: {e}")
    result = default_xml
```

**Features:**
- Input validation (type checking, size limits)
- Helpful error messages
- Optional strict mode for output validation
- Configurable empty string handling

**Parameters:**
- `xml_string`: The XML string to repair
- `strict`: If True, validate repaired output (default: False)
- `allow_empty`: If True, accept empty strings (default: False)
- `max_size`: Maximum input size in bytes (default: 100MB, None = unlimited)

```python
# Strict mode - validates output structure
result = repair_xml_safe('<root><item>', strict=True)

# Allow empty input
result = repair_xml_safe('', allow_empty=True)  # Returns ''

# Custom size limit
result = repair_xml_safe(large_xml, max_size=10_000_000)  # 10MB limit
```

**Perfect for:**
- Production applications requiring reliability
- User-facing APIs where validation matters
- Systems that need clear error messages and logging
- Applications with specific input size constraints

### Lenient Mode (Never Raises)

Use `repair_xml_lenient()` when you want maximum fault tolerance:

```python
from xenon import repair_xml_lenient

# Always returns a string, never raises
result = repair_xml_lenient(None)  # Returns ''
result = repair_xml_lenient(123)   # Returns '123'
result = repair_xml_lenient('<root><item')  # Returns '<root><item></item></root>'
```

**Perfect for:**
- Batch processing with mixed data quality
- When you prefer empty results over exceptions
- Rapid prototyping

### Default Mode (Original Behavior)

The original `repair_xml()` function is still available and works as before:

```python
from xenon import repair_xml

result = repair_xml('<root><item>')  # Works as always
```

**Perfect for:**
- Simple scripts and utilities
- Performance-critical paths (minimal overhead)
- Controlled environments with trusted input
- Quick testing and experimentation

**Note:** This function does not validate input types - passing `None` or non-string values will cause errors.

### Exception Hierarchy

All Xenon errors inherit from `XenonException`:

```python
from xenon import XenonException, ValidationError, RepairError

try:
    result = repair_xml_safe(xml_string)
except ValidationError as e:
    # Input was invalid (wrong type, too large, etc.)
    print(f"Validation failed: {e}")
except RepairError as e:
    # Internal error during repair
    print(f"Repair failed: {e}")
except XenonException as e:
    # Catch all Xenon errors
    print(f"Xenon error: {e}")
```

**Exception Types:**
- `XenonException`: Base exception for all Xenon errors
- `ValidationError`: Invalid input (wrong type, empty, too large)
- `MalformedXMLError`: Output still invalid in strict mode
- `RepairError`: Internal error during repair process

## Function Reference

### Core Functions (v1.0.0+)

#### `repair_xml_safe(xml_string, trust, ...) -> str`

**üîí v1.0.0:** Safely repair XML with trust-based security.

**Required Parameters:**
- `xml_string` (str | bytes): The XML string to repair
- `trust` (TrustLevel): **REQUIRED** - Trust level of input source
  - `TrustLevel.UNTRUSTED`: LLM output, user uploads, external APIs
  - `TrustLevel.INTERNAL`: Internal services, config files
  - `TrustLevel.TRUSTED`: Test fixtures, hardcoded literals

**Optional Parameters:**
- `strict` (bool): Validate output structure (default: False)
- `allow_empty` (bool): Accept empty input (default: False)
- `max_size` (int): Max size in bytes, None = unlimited (default: 100MB)
- `format_output` (str): Output format - 'pretty', 'compact', 'minify' (default: None)
- `html_entities` (str): HTML entity handling - 'numeric', 'preserve' (default: None)
- `normalize_unicode` (bool): Apply Unicode normalization (default: False)
- `schema_content` (str): Content of the schema (XSD or DTD) for post-repair validation (default: None)
- `validate_output_schema` (bool): If True, validate repaired XML against `schema_content` (default: False, but True for UNTRUSTED if schema_content is provided)
- Override security flags (use with caution):
  - `strip_dangerous_pis` (bool): Override trust level default
  - `strip_external_entities` (bool): Override trust level default
  - `strip_dangerous_tags` (bool): Override trust level default
- XML compliance features:
  - `wrap_multiple_roots` (bool): Wrap multiple roots (default: False)
  - `sanitize_invalid_tags` (bool): Fix invalid tag names (default: False)
  - `fix_namespace_syntax` (bool): Fix namespace syntax (default: False)
  - `auto_wrap_cdata` (bool): Auto-wrap code in CDATA (default: False)

**Returns:**
- Repaired XML string

**Raises:**
- `ValidationError`: Invalid input
- `MalformedXMLError`: Invalid output (strict mode only)
- `SecurityError`: Security limits exceeded (max depth, entity expansion)
- `RepairError`: Internal repair error

**Examples:**
```python
from xenon import repair_xml_safe, TrustLevel

# LLM output - maximum security
result = repair_xml_safe(llm_xml, trust=TrustLevel.UNTRUSTED)

# Internal service - moderate security
result = repair_xml_safe(service_xml, trust=TrustLevel.INTERNAL)

# Test fixture - no security overhead
result = repair_xml_safe(TEST_XML, trust=TrustLevel.TRUSTED)

# Override security for specific case
result = repair_xml_safe(
    xml,
    trust=TrustLevel.TRUSTED,  # Base level
    strip_dangerous_pis=True   # But still strip PIs
)
```

---

#### `parse_xml_safe(xml_string, trust, ...) -> dict`

**üîí v1.0.0:** Safely parse malformed XML to dictionary with trust-based security.

**Parameters:**
- Same as `repair_xml_safe()`

**Returns:**
- Dictionary representation of the XML

**Raises:**
- Same exceptions as `repair_xml_safe()`

---

#### `batch_repair(xml_list, trust, ...) -> List[Tuple[str, Optional[Exception]]]`

**üîí v1.0.0:** Batch repair multiple XML strings with error handling.

**Required Parameters:**
- `xml_strings` (List[str]): List of XML strings to repair
- `trust` (TrustLevel): **REQUIRED** - Trust level for all inputs

**Optional Parameters:**
- `show_progress` (bool): Show progress indicator (default: False)
- `on_error` (str): Error handling - 'skip', 'raise', 'return_empty' (default: 'skip')
- Additional kwargs passed to `repair_xml_safe()`

**Returns:**
- List of (repaired_xml, error) tuples

**Example:**
```python
from xenon import batch_repair, TrustLevel

xml_batch = ['<root>test1', '<root>test2</root>']
results = batch_repair(xml_batch, trust=TrustLevel.UNTRUSTED)

for xml, error in results:
    if error:
        print(f"Failed: {error}")
    else:
        print(f"Success: {xml}")
```

---

#### Legacy Functions (Deprecated)

**‚ö†Ô∏è These functions are deprecated and will be removed in v2.0.0. Use trust-based functions instead.**

#### `repair_xml(xml_string: str) -> str`

**Deprecated:** Use `repair_xml_safe(xml, trust=TrustLevel.TRUSTED)` instead.

#### `parse_xml(xml_string: str) -> dict`

**Deprecated:** Use `parse_xml_safe(xml, trust=TrustLevel.TRUSTED)` instead.

---

### Lenient Functions (Never Raise)

#### `repair_xml_lenient(xml_input) -> str`

Repair XML in lenient mode - never raises exceptions.

**Parameters:**
- `xml_input` (Any): Any input (None, int, list, str, etc.)

**Returns:**
- Repaired XML string, or empty string on any error

---

#### `parse_xml_lenient(xml_input) -> dict`

Parse XML in lenient mode - never raises exceptions.

**Parameters:**
- `xml_input` (Any): Any input

**Returns:**
- Dictionary representation, or empty dict on any error

---

## Advanced Usage

### Using Configuration Objects (v0.5.0+)

For complex setups, use the configuration object API:

```python
from xenon import XMLRepairEngine, XMLRepairConfig, SecurityFlags, RepairFlags

# Create a configuration
config = XMLRepairConfig(
    match_threshold=2,  # Typo detection sensitivity
    security=SecurityFlags.STRIP_DANGEROUS_PIS |
             SecurityFlags.STRIP_EXTERNAL_ENTITIES |
             SecurityFlags.STRIP_DANGEROUS_TAGS,
    repair=RepairFlags.SANITIZE_INVALID_TAGS |
           RepairFlags.FIX_NAMESPACE_SYNTAX |
           RepairFlags.WRAP_MULTIPLE_ROOTS
)

# Create engine with config
engine = XMLRepairEngine(config)

# Use it
result = engine.repair_xml(untrusted_xml)
```

### Using Individual Components

For custom processing pipelines:

```python
from xenon import XMLPreprocessor, XMLSecurityFilter, XMLRepairConfig

# Preprocess tags only
config = XMLRepairConfig.from_booleans(sanitize_invalid_tags=True)
preprocessor = XMLPreprocessor(config)
cleaned = preprocessor.preprocess('<123tag>data</123tag>')
# Result: '<tag_123tag>data</tag_123tag>'

# Security checks
security = XMLSecurityFilter(config)
if security.is_dangerous_tag('script'):
    print("Found dangerous tag!")
```

### Performance Optimization

For batch processing, reuse the engine:

```python
from xenon import XMLRepairEngine

# Create engine once
engine = XMLRepairEngine()

# Reuse for multiple repairs
results = [engine.repair_xml(xml) for xml in xml_batch]
```

## Try It Out

**Interactive Notebook**: Try Xenon in your browser with our Google Colab notebook - no installation required!

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/MarsZDF/xenon/blob/main/xenon_demo.ipynb)

## Development

```bash
# Clone the repository
git clone https://github.com/xenon-xml/xenon.git
cd xenon

# Install development dependencies
pip install -e ".[dev]"

# Run tests (149 comprehensive tests)
python -m pytest tests/

# Run specific test file
python -m pytest tests/test_core.py -v
```

## Performance

Xenon is designed for production use with LLM-generated XML:

- **Fast**: Single-pass processing with optimized algorithms
- **Efficient**: Minimal memory overhead (~1MB for typical documents)
- **Scalable**: Handles documents up to 100MB by default (configurable)

**v0.5.0 Performance Improvements:**
- ~2x faster preprocessing when using multiple repair features
- Single-pass tag transformation (vs multiple regex passes)
- Reduced memory usage through better component separation

## License

MIT License - see LICENSE file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## Version History

- **v1.0.0** (2025-12-03): üîí **BREAKING CHANGES** - Secure-by-default with mandatory trust levels, SecurityError exception, streaming security filtering, XMLRepairEngine.from_trust_level() factory method, **optional schema/DTD validation**, and enhanced XSS protection. [See migration guide above](#-v100-secure-by-default-breaking-changes)
- **v0.7.0** (2025-12-02): Real-time streaming XML repair for LLM token-by-token output
- **v0.6.0** (2025-12-01): Diff reporting, XML formatting, HTML entities, encoding detection, enhanced errors
- **v0.5.0** (2025-11-29): XML compliance features, configuration API, architectural refactoring
- **v0.4.0** (2025-11-28): Security features, safe mode, error handling
- **v0.3.0**: Typo detection, similarity matching
- **v0.2.0**: Namespace support, CDATA wrapping
- **v0.1.0**: Initial release
