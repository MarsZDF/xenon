# Xenon

A robust, zero-dependency Python library for cleaning up malformed XML generated by Large Language Models (LLMs).

## Features

- **Zero Dependencies**: Uses only Python Standard Library
- **Stack-based Parser**: Deterministic handling of nested structures and truncation
- **LLM-Focused**: Specifically designed to handle common LLM XML generation failures
- **Smart Tag Matching**: Detects and fixes typos in closing tags using similarity matching
- **Robust Error Handling**: Production-ready with comprehensive validation and error recovery
- **Multiple Modes**: Choose between strict, default, or lenient error handling
- **Simple Interface**: Easy-to-use functions for common use cases
- **üÜï v0.6.0**: Diff reporting, formatting, HTML entities, and encoding detection
- **v0.5.0**: Advanced XML compliance features and cleaner configuration API

## Installation

Install directly from GitHub:

```bash
pip install git+https://github.com/MarsZDF/xenon.git
```

Or clone and install locally:

```bash
git clone https://github.com/MarsZDF/xenon.git
cd xenon
pip install -e .
```

> **Note**: This package is not yet published to PyPI. Once published, you'll be able to install with `pip install xenon`.

## ‚ö†Ô∏è Security Warning & Features

**Xenon is a syntactic repair tool, NOT a complete security sanitizer.**

**Security features** (optional, OFF by default):
- ‚úì Strip dangerous processing instructions (PHP, ASP, JSP)
- ‚úì Strip external entity declarations (XXE prevention)
- ‚úì Strip dangerous tags (script, iframe, object, embed)

**Xenon does NOT**:
- ‚úó Filter malicious Unicode
- ‚úó Validate XML content semantics
- ‚úó Provide complete XSS protection

**For untrusted input:** Use the security flags AND add additional validation layers.

See [SECURITY.md](SECURITY.md) for detailed threat model and best practices.

## Quick Start

```python
from xenon import repair_xml, parse_xml

# Repair malformed XML
malformed = 'Sure, here is the XML: <root><user name=john'
repaired = repair_xml(malformed)
print(repaired)  # <root><user name="john"></user></root>

# Parse to dictionary
result = parse_xml(malformed)
print(result)    # {'root': {'user': {'@attributes': {'name': 'john'}}}}
```

## What's New in v0.6.0 üÜï

### Diff/Patch Reporting
Understand exactly what changed during repair:

```python
from xenon import repair_xml_with_diff

result, report = repair_xml_with_diff('<root><item>test')

# Get unified diff
print(report.to_unified_diff())
# --- Original
# +++ Repaired
# @@ -1 +1 @@
# -<root><item>test
# +<root><item>test</item></root>

# Get HTML diff for visualization
html = report.to_html_diff()
with open('diff.html', 'w') as f:
    f.write(html)

# Get statistics
stats = report.get_diff_summary()
print(f"Lines added: {stats['lines_added']}")
print(f"Similarity: {stats['similarity_ratio']:.1%}")
```

### Analyzing Repairs
Understand what repairs were performed and why:

```python
from xenon import repair_xml_with_report, RepairType

result, report = repair_xml_with_report('<root><?php code?><item>test & data')

# Get human-readable summary
print(report.summary())
# Performed 3 repair(s):
#   - [dangerous_pi_stripped] Removed dangerous PI
#   - [unescaped_entity] Escaped & character
#   - [truncation] Added closing tags

# Check if repairs were needed
if report:  # Truthy if any repairs performed
    print(f"Made {len(report)} repairs")

# Analyze by repair type
for action in report.actions:
    print(f"Type: {action.repair_type.value}")
    print(f"Description: {action.description}")
    if action.before:
        print(f"Changed: '{action.before}' ‚Üí '{action.after}'")

# Group repairs by type
grouped = report.by_type()
for repair_type, actions in grouped.items():
    print(f"{repair_type.value}: {len(actions)} occurrences")

# Get detailed statistics
stats = report.statistics()
print(f"Total repairs: {stats['total_repairs']}")
print(f"Truncations fixed: {stats.get('truncation_count', 0)}")

# Check for security issues
if report.has_security_issues():
    print("‚ö†Ô∏è  Security repairs were performed - review input source")

# Export to JSON for logging/analysis
import json
json_data = json.dumps(report.to_dict(), indent=2)
```

**15 Repair Types:**
- `TRUNCATION` - Fixed incomplete XML
- `CONVERSATIONAL_FLUFF` - Removed non-XML text
- `UNESCAPED_ENTITY` - Escaped &, <, >
- `MALFORMED_ATTRIBUTE` - Fixed attribute syntax
- `CDATA_WRAPPED` - Wrapped code in CDATA
- `TAG_TYPO` / `TAG_CASE_MISMATCH` - Fixed tag issues
- `DANGEROUS_PI_STRIPPED` - Removed <?php ?>, etc.
- `DANGEROUS_TAG_STRIPPED` - Removed <script>, etc.
- `EXTERNAL_ENTITY_STRIPPED` - XXE prevention
- And more... (see [API Reference](docs/API_REFERENCE.md))

### Smart Formatting
Format XML output for readability:

```python
from xenon import format_xml

xml = '<root><item>test</item><another>data</another></root>'

# Pretty-print with indentation
pretty = format_xml(xml, style='pretty', indent='  ')
print(pretty)
# <root>
#   <item>test</item>
#   <another>data</another>
# </root>

# Minify for compact output
compact = format_xml(xml, style='minify')
# <root><item>test</item><another>data</another></root>

# One tag per line (compact)
result = format_xml(xml, style='compact')
```

### HTML Entity Support
Handle HTML entities from web-trained LLMs:

```python
from xenon import convert_html_entities, normalize_entities

# Convert HTML entities to numeric XML entities
text = "Price: &euro;50 &mdash; &copy;2024"
result = convert_html_entities(text)
# Result: "Price: &#8364;50 &#8212; &#169;2024"

# Normalize all entities
text = "&lt;test&gt; &copy;2024 &#169;2024"
result = normalize_entities(text, mode='numeric')
# Converts HTML entities, preserves XML entities
```

Supports 40+ common HTML entities: `&nbsp;`, `&copy;`, `&euro;`, `&mdash;`, `&ldquo;`, `&rarr;`, Greek letters, math symbols, and more.

### Encoding Detection
Auto-detect and normalize encodings:

```python
from xenon import detect_encoding, normalize_encoding

# Detect encoding from BOM or XML declaration
data = b'\xef\xbb\xbf<?xml version="1.0"?><root/>'
encoding, confidence = detect_encoding(data)
# ('utf-8-sig', 1.0)

# Normalize to UTF-8 with Unicode normalization
result = normalize_encoding(data, normalize_unicode=True)
# Returns: '<root/>' as normalized string
```

### üöÄ All v0.6.0 Features in One Call
Use all features together with the integrated `repair_xml_safe()`:

```python
from xenon import repair_xml_safe

# Bytes input + all v0.6.0 features in ONE call!
result = repair_xml_safe(
    b'<root><?php code?><p>&euro;50</p><item>data',  # Accepts bytes
    # v0.6.0 Features:
    format_output='pretty',         # Pretty-print output
    html_entities='numeric',        # Convert HTML entities
    normalize_unicode=True,         # Apply NFC normalization
    # Plus v0.5.0 security features:
    strip_dangerous_pis=True,       # Remove <?php ?>
    auto_wrap_cdata=True,           # Wrap code in CDATA
    strict=True                     # Validate output
)

print(result)
# <root>
#   <p>‚Ç¨50</p>
#   <item>data</item>
# </root>
```

### Utility Functions
Powerful utilities exposed in v0.6.0:

```python
from xenon import (
    batch_repair,              # Batch processing
    stream_repair,             # Streaming for large datasets
    validate_xml_structure,    # Lightweight validation
    extract_text_content,      # Extract text from XML
    decode_xml                 # Auto-detect encoding
)

# Batch repair with error handling
xml_batch = ['<root>test1', '<root>test2</root>', '<root>test3']
results = batch_repair(xml_batch, on_error='skip')
for xml, error in results:
    if error:
        print(f"Failed: {error}")
    else:
        print(f"Success: {xml}")

# Stream repair for huge datasets
def xml_generator():
    for i in range(10000):
        yield f'<item id="{i}">data{i}'

for repaired, error in stream_repair(xml_generator()):
    if not error:
        process(repaired)

# Validate structure before expensive operations
is_valid, issues = validate_xml_structure(xml)
if not is_valid:
    print(f"Issues found: {issues}")

# Extract plain text from XML
text = extract_text_content('<root><p>Hello</p><p>World</p></root>')
# 'HelloWorld'
```

### Enhanced Error Messages
Get precise error context with line/column information:

```python
from xenon import repair_xml_safe, get_line_column, get_context_snippet

xml = """<root>
    <item id=invalid>
        <name>Test</name>
    </item>
</root>"""

try:
    result = repair_xml_safe(xml, strict=True)
except Exception as e:
    # Exceptions now include line/column context
    print(f"Error at line {e.line}, column {e.column}")
    print(f"Context: {e.context}")
    # Error at line 2, column 15
    # Context: '...id=invalid>...'

# Or use helper functions
position = xml.find("invalid")
line, col = get_line_column(xml, position)
context = get_context_snippet(xml, position, max_length=40)
print(f"Found at line {line}, column {col}: {context}")
```

## What's New in v0.5.0

### New XML Compliance Features

```python
from xenon import repair_xml_safe

# 1. Fix invalid tag names (starts with number, contains spaces)
xml = '<123tag>data</123tag>'
result = repair_xml_safe(xml, sanitize_invalid_tags=True)
# Result: <tag_123tag>data</tag_123tag>

xml = '<tag with spaces>data</tag with spaces>'
result = repair_xml_safe(xml, sanitize_invalid_tags=True)
# Result: <tag_with_spaces>data</tag_with_spaces>

# 2. Fix invalid namespace syntax (multiple colons, etc.)
xml = '<bad::ns>data</bad::ns>'
result = repair_xml_safe(xml, fix_namespace_syntax=True)
# Result: <bad_ns>data</bad_ns>

xml = '<ns1:ns2:tag>data</ns1:ns2:tag>'
result = repair_xml_safe(xml, fix_namespace_syntax=True)
# Result: <ns1:ns2_tag>data</ns1:ns2_tag>

# 3. Wrap multiple root elements
xml = '<root1>data1</root1><root2>data2</root2>'
result = repair_xml_safe(xml, wrap_multiple_roots=True)
# Result: <document><root1>data1</root1><root2>data2</root2></document>

# 4. Auto-wrap code content in CDATA sections
xml = '<code>if (x < 5 && y > 10) { return true; }</code>'
result = repair_xml_safe(xml, auto_wrap_cdata=True)
# Result: <code><![CDATA[if (x < 5 && y > 10) { return true; }]]></code>
# Works with: code, script, pre, sql, xpath, regex, query, formula, expression

# 5. Improved entity escaping (no double-escaping!)
xml = '<root>&lt;already&gt; & new</root>'
result = repair_xml_safe(xml)
# Result: <root>&lt;already&gt; &amp; new</root>
# (preserves existing entities, escapes new ones)

# 6. Attribute value escaping
xml = '<root attr="value & more">text</root>'
result = repair_xml_safe(xml)
# Result: <root attr="value &amp; more">text</root>
```

### Cleaner Configuration API (Recommended)

**New in v0.5.0:** Use configuration objects for complex setups:

```python
from xenon import XMLRepairEngine, XMLRepairConfig, SecurityFlags, RepairFlags

# Old way (still works!)
engine = XMLRepairEngine(
    strip_dangerous_pis=True,
    strip_external_entities=True,
    sanitize_invalid_tags=True,
    fix_namespace_syntax=True
)

# New way (recommended for clarity)
config = XMLRepairConfig(
    security=SecurityFlags.STRIP_DANGEROUS_PIS | SecurityFlags.STRIP_EXTERNAL_ENTITIES,
    repair=RepairFlags.SANITIZE_INVALID_TAGS | RepairFlags.FIX_NAMESPACE_SYNTAX | RepairFlags.AUTO_WRAP_CDATA
)
engine = XMLRepairEngine(config)

# Both produce the same result!
result = engine.repair_xml(malformed_xml)
```

**Benefits:**
- Cleaner, more maintainable code
- Better IDE autocomplete
- Easier to see which features are enabled
- Groups related features logically

## Security Features

For untrusted input, use `repair_xml_safe()` with security flags:

```python
from xenon import repair_xml_safe

# Untrusted XML with potential security threats
untrusted_xml = '''<?php system("whoami"); ?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>
    <script>alert('XSS')</script>
    <data>clean content</data>
</root>'''

# Repair with all security features enabled
safe_xml = repair_xml_safe(
    untrusted_xml,
    strip_dangerous_pis=True,      # Remove PHP/ASP/JSP code
    strip_external_entities=True,   # Remove DOCTYPE with entities
    strip_dangerous_tags=True       # Remove script/iframe/object/embed tags
)

# Result: <root>alert('XSS')<data>clean content</data></root>
# - PHP code removed
# - DOCTYPE removed
# - <script> tags removed (content preserved)
```

**Important:** These features provide basic protection but are NOT a complete security solution. Always validate and sanitize untrusted input using additional security layers.

## Supported Failure Modes

### 1. Truncation/Cut-off
When LLMs run out of tokens mid-tag:
```python
malformed = '<root><user name="alice"'
repaired = repair_xml(malformed)
# Result: <root><user name="alice"></user></root>
```

### 2. Conversational Fluff
XML embedded in conversational text:
```python
malformed = 'Here is your XML data:\n<root><message>Hello</message></root>\nHope this helps!'
repaired = repair_xml(malformed)
# Result: <root><message>Hello</message></root>
```

### 3. Malformed Attributes
Missing quotes around attribute values:
```python
malformed = '<item id=123 type=product name=widget>'
repaired = repair_xml(malformed)
# Result: <item id="123" type="product" name="widget"></item>
```

### 4. Unescaped Entities
Unescaped `&` or `<` in text content:
```python
malformed = '<desc>Barnes & Noble sells books < $20</desc>'
repaired = repair_xml(malformed)
# Result: <desc>Barnes &amp; Noble sells books &lt; $20</desc>
```

### 5. Code Content (CDATA)
Automatically wrap code and special content in CDATA sections:
```python
malformed = '<code>function test() { return x && y; }</code>'
repaired = repair_xml(malformed)
# Result: <code><![CDATA[function test() { return x && y; }]]></code>
```

### 6. Mismatched Tag Case
Case-insensitive tag matching (uses opening tag's case):
```python
malformed = '<Root><Item>text</item></Root>'
repaired = repair_xml(malformed)
# Result: <Root><Item>text</Item></Root>
```

### 7. Mismatched Tag Names (Typos)
Detects and fixes typos in closing tags using similarity matching:
```python
malformed = '<user>John Doe</usr>'
repaired = repair_xml(malformed)
# Result: <user>John Doe</user>

# Also handles multiple typos
malformed = '<users><user>Alice</usr><user>Bob</user></usrs>'
repaired = repair_xml(malformed)
# Result: <users><user>Alice</user><user>Bob</user></users>
```

**How it works:**
- Uses Levenshtein distance to detect typos (up to 2 character differences)
- Matches closing tags to nearest opening tag on the stack
- Fast: O(m√ón) where m,n are tag name lengths (~10-20 chars)
- Zero dependencies: pure Python stdlib

### 8. Missing Namespace Declarations
Auto-inject common namespace declarations:
```python
malformed = '<soap:Envelope><soap:Body>test</soap:Body></soap:Envelope>'
repaired = repair_xml(malformed)
# Result: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
#         <soap:Body>test</soap:Body></soap:Envelope>
```

### 9. Duplicate Attributes
Remove duplicate attributes (keeps first occurrence):
```python
malformed = '<item id="1" name="foo" id="2">'
repaired = repair_xml(malformed)
# Result: <item id="1" name="foo"></item>
```

### 10. Invalid Tag Names üÜï
Fix XML tag names that violate XML specification:
```python
malformed = '<123illegal>data</123illegal>'
repaired = repair_xml_safe(malformed, sanitize_invalid_tags=True)
# Result: <tag_123illegal>data</tag_123illegal>

malformed = '<tag-with spaces>data</tag-with spaces>'
repaired = repair_xml_safe(malformed, sanitize_invalid_tags=True)
# Result: <tag-with_spaces>data</tag-with_spaces>
```

### 11. Invalid Namespace Syntax üÜï
Fix namespace syntax that violates XML specification:
```python
malformed = '<bad::ns>data</bad::ns>'
repaired = repair_xml_safe(malformed, fix_namespace_syntax=True)
# Result: <bad_ns>data</bad_ns>

malformed = '<ns1:ns2:tag>data</ns1:ns2:tag>'
repaired = repair_xml_safe(malformed, fix_namespace_syntax=True)
# Result: <ns1:ns2_tag>data</ns1:ns2_tag>
```

### 12. Multiple Root Elements üÜï
Wrap multiple root elements to create valid XML:
```python
malformed = '<root1>data1</root1><root2>data2</root2>'
repaired = repair_xml_safe(malformed, wrap_multiple_roots=True)
# Result: <document><root1>data1</root1><root2>data2</root2></document>
```

## Error Handling

Xenon provides three different modes for different use cases:

### Safe Mode (Recommended for Production)

Use `repair_xml_safe()` for robust error handling with helpful error messages:

```python
from xenon import repair_xml_safe, ValidationError

try:
    result = repair_xml_safe(llm_output)
except ValidationError as e:
    print(f"Invalid input: {e}")
    result = default_xml
```

**Features:**
- Input validation (type checking, size limits)
- Helpful error messages
- Optional strict mode for output validation
- Configurable empty string handling

**Parameters:**
- `xml_string`: The XML string to repair
- `strict`: If True, validate repaired output (default: False)
- `allow_empty`: If True, accept empty strings (default: False)
- `max_size`: Maximum input size in bytes (default: 100MB, None = unlimited)

```python
# Strict mode - validates output structure
result = repair_xml_safe('<root><item>', strict=True)

# Allow empty input
result = repair_xml_safe('', allow_empty=True)  # Returns ''

# Custom size limit
result = repair_xml_safe(large_xml, max_size=10_000_000)  # 10MB limit
```

**Perfect for:**
- Production applications requiring reliability
- User-facing APIs where validation matters
- Systems that need clear error messages and logging
- Applications with specific input size constraints

### Lenient Mode (Never Raises)

Use `repair_xml_lenient()` when you want maximum fault tolerance:

```python
from xenon import repair_xml_lenient

# Always returns a string, never raises
result = repair_xml_lenient(None)  # Returns ''
result = repair_xml_lenient(123)   # Returns '123'
result = repair_xml_lenient('<root><item')  # Returns '<root><item></item></root>'
```

**Perfect for:**
- Batch processing with mixed data quality
- When you prefer empty results over exceptions
- Rapid prototyping

### Default Mode (Original Behavior)

The original `repair_xml()` function is still available and works as before:

```python
from xenon import repair_xml

result = repair_xml('<root><item>')  # Works as always
```

**Perfect for:**
- Simple scripts and utilities
- Performance-critical paths (minimal overhead)
- Controlled environments with trusted input
- Quick testing and experimentation

**Note:** This function does not validate input types - passing `None` or non-string values will cause errors.

### Exception Hierarchy

All Xenon errors inherit from `XenonException`:

```python
from xenon import XenonException, ValidationError, RepairError

try:
    result = repair_xml_safe(xml_string)
except ValidationError as e:
    # Input was invalid (wrong type, too large, etc.)
    print(f"Validation failed: {e}")
except RepairError as e:
    # Internal error during repair
    print(f"Repair failed: {e}")
except XenonException as e:
    # Catch all Xenon errors
    print(f"Xenon error: {e}")
```

**Exception Types:**
- `XenonException`: Base exception for all Xenon errors
- `ValidationError`: Invalid input (wrong type, empty, too large)
- `MalformedXMLError`: Output still invalid in strict mode
- `RepairError`: Internal error during repair process

## Function Reference

### Core Functions

#### `repair_xml(xml_string: str) -> str`

Original repair function without error handling.

**Parameters:**
- `xml_string`: The potentially malformed XML string

**Returns:**
- A well-formed XML string

**Note:** No input validation - use `repair_xml_safe()` for production.

---

#### `parse_xml(xml_string: str) -> dict`

Repairs and parses malformed XML to a dictionary.

**Parameters:**
- `xml_string`: The potentially malformed XML string

**Returns:**
- A nested dictionary representation of the XML

**Dictionary Structure:**
- Element text content: stored as string value or `#text` key
- Attributes: stored under `@attributes` key
- Multiple elements with same name: converted to list

---

### Safe Functions (Recommended)

#### `repair_xml_safe(...) -> str`

Safely repair XML with comprehensive error handling and optional security features.

**Parameters:**
- `xml_string` (str): The XML string to repair
- `strict` (bool): Validate output structure (default: False)
- `allow_empty` (bool): Accept empty input (default: False)
- `max_size` (int): Max size in bytes, None = unlimited (default: 100MB)
- `strip_dangerous_pis` (bool): Strip dangerous processing instructions like PHP, ASP, JSP (default: False)
- `strip_external_entities` (bool): Strip DOCTYPE declarations with external entities for XXE prevention (default: False)
- `strip_dangerous_tags` (bool): Strip potentially dangerous tags (script, iframe, object, embed) for XSS prevention (default: False)
- `wrap_multiple_roots` (bool): Wrap multiple root elements in synthetic `<document>` root (default: False) **[NEW in v0.5.0]**
- `sanitize_invalid_tags` (bool): Fix invalid XML tag names (default: False) **[NEW in v0.5.0]**
- `fix_namespace_syntax` (bool): Fix invalid namespace syntax (default: False) **[NEW in v0.5.0]**

**Returns:**
- Repaired XML string

**Raises:**
- `ValidationError`: Invalid input
- `MalformedXMLError`: Invalid output (strict mode only)
- `RepairError`: Internal repair error

---

#### `parse_xml_safe(xml_string, strict=False, allow_empty=False, max_size=None) -> dict`

Safely parse malformed XML to dictionary.

**Parameters:**
- Same as `repair_xml_safe()`

**Returns:**
- Dictionary representation of the XML

**Raises:**
- Same exceptions as `repair_xml_safe()`

---

### Lenient Functions (Never Raise)

#### `repair_xml_lenient(xml_input) -> str`

Repair XML in lenient mode - never raises exceptions.

**Parameters:**
- `xml_input` (Any): Any input (None, int, list, str, etc.)

**Returns:**
- Repaired XML string, or empty string on any error

---

#### `parse_xml_lenient(xml_input) -> dict`

Parse XML in lenient mode - never raises exceptions.

**Parameters:**
- `xml_input` (Any): Any input

**Returns:**
- Dictionary representation, or empty dict on any error

---

## Advanced Usage

### Using Configuration Objects (v0.5.0+)

For complex setups, use the configuration object API:

```python
from xenon import XMLRepairEngine, XMLRepairConfig, SecurityFlags, RepairFlags

# Create a configuration
config = XMLRepairConfig(
    match_threshold=2,  # Typo detection sensitivity
    security=SecurityFlags.STRIP_DANGEROUS_PIS |
             SecurityFlags.STRIP_EXTERNAL_ENTITIES |
             SecurityFlags.STRIP_DANGEROUS_TAGS,
    repair=RepairFlags.SANITIZE_INVALID_TAGS |
           RepairFlags.FIX_NAMESPACE_SYNTAX |
           RepairFlags.WRAP_MULTIPLE_ROOTS
)

# Create engine with config
engine = XMLRepairEngine(config)

# Use it
result = engine.repair_xml(untrusted_xml)
```

### Using Individual Components

For custom processing pipelines:

```python
from xenon import XMLPreprocessor, XMLSecurityFilter, XMLRepairConfig

# Preprocess tags only
config = XMLRepairConfig.from_booleans(sanitize_invalid_tags=True)
preprocessor = XMLPreprocessor(config)
cleaned = preprocessor.preprocess('<123tag>data</123tag>')
# Result: '<tag_123tag>data</tag_123tag>'

# Security checks
security = XMLSecurityFilter(config)
if security.is_dangerous_tag('script'):
    print("Found dangerous tag!")
```

### Performance Optimization

For batch processing, reuse the engine:

```python
from xenon import XMLRepairEngine

# Create engine once
engine = XMLRepairEngine()

# Reuse for multiple repairs
results = [engine.repair_xml(xml) for xml in xml_batch]
```

## Try It Out

**Interactive Notebook**: Try Xenon in your browser with our Google Colab notebook - no installation required!

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/MarsZDF/xenon/blob/main/xenon_demo.ipynb)

## Development

```bash
# Clone the repository
git clone https://github.com/xenon-xml/xenon.git
cd xenon

# Install development dependencies
pip install -e ".[dev]"

# Run tests (149 comprehensive tests)
python -m pytest tests/

# Run specific test file
python -m pytest tests/test_core.py -v
```

## Performance

Xenon is designed for production use with LLM-generated XML:

- **Fast**: Single-pass processing with optimized algorithms
- **Efficient**: Minimal memory overhead (~1MB for typical documents)
- **Scalable**: Handles documents up to 100MB by default (configurable)

**v0.5.0 Performance Improvements:**
- ~2x faster preprocessing when using multiple repair features
- Single-pass tag transformation (vs multiple regex passes)
- Reduced memory usage through better component separation

## License

MIT License - see LICENSE file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## Version History

- **v0.5.0** (2025-11-29): XML compliance features, configuration API, architectural refactoring
- **v0.4.0** (2025-11-28): Security features, safe mode, error handling
- **v0.3.0**: Typo detection, similarity matching
- **v0.2.0**: Namespace support, CDATA wrapping
- **v0.1.0**: Initial release
