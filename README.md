# Xenon

[![CI](https://github.com/MarsZDF/xenon/actions/workflows/ci.yml/badge.svg)](https://github.com/MarsZDF/xenon/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/MarsZDF/xenon/branch/main/graph/badge.svg)](https://codecov.io/gh/MarsZDF/xenon)
[![PyPI version](https://badge.fury.io/py/xenon.svg)](https://badge.fury.io/py/xenon)

**Xenon** is a robust, zero-dependency Python library designed to clean up, repair, and secure malformed XML generated by Large Language Models (LLMs).

In the era of RAG and AI agents, applications increasingly rely on structured data outputs. However, LLMs often generate messy XML‚Äîmissing closing tags, conversational fluff, hallucinations, or XSS vulnerabilities. **Xenon** bridges the gap between raw LLM output and reliable application code.

## üöÄ Key Features

- **LLM-Focused Repair**: specifically handles truncation, hallucinations, and conversational text ("Here is your XML: ...").
- **Secure by Default**: Explicit `TrustLevel` system to prevent XSS and injection attacks from untrusted sources.
- **Real-Time Streaming**: Repair XML token-by-token as it arrives from the LLM (compatible with OpenAI/Anthropic streams).
- **Zero Dependencies**: Lightweight and fast; uses only the Python Standard Library.
- **Smart Matching**: Uses Levenshtein distance to fix typoed tags (e.g., `</usre>` ‚Üí `</user>`).
- **Formatting & Diffs**: Built-in pretty-printing and diff generation to visualize repairs.

## ‚ùì Why Xenon?

You might ask: *"Why not just use BeautifulSoup, lxml, or xml.etree?"*

Standard parsers are designed for **well-formed XML**. When they encounter the chaos of LLM output (hallucinated tags, unescaped characters, cut-off strings), they simply crash:

| Issue | `lxml` / `BeautifulSoup` (xml) | **Xenon** |
|-------|--------------------------------|-----------|
| **Truncated XML** (cut-off response) | ‚ùå `XMLSyntaxError: unexpected end of data` | ‚úÖ Auto-closes open tags & structures |
| **Conversational Fluff** ("Here is...") | ‚ùå `XMLSyntaxError: Start tag expected` | ‚úÖ Extracts XML from text |
| **Malformed Attributes** (`id=1`) | ‚ùå `XMLSyntaxError` | ‚úÖ Adds missing quotes |
| **Memory Usage** | ‚ö†Ô∏è Loads full DOM | ‚ö° Streaming mode (constant memory) |
| **Security** | ‚ö†Ô∏è Vulnerable to XXE/Billion Laughs by default | üîí Secure-by-default (`TrustLevel`) |

Xenon is **not** a replacement for `lxml` for valid XML; it is the **ambulance** that gets your data to the hospital alive so `lxml` can operate on it later.

## Installation

```bash
# Install directly from GitHub
pip install git+https://github.com/MarsZDF/xenon.git

# Or clone and install locally
git clone https://github.com/MarsZDF/xenon.git
cd xenon
pip install -e .
```

## ‚ö° Quick Start

Xenon requires you to specify a **Trust Level** for your input. This ensures you don't accidentally expose your application to security threats from untrusted LLM outputs.

```python
from xenon import repair_xml_safe, parse_xml_safe, TrustLevel

# 1. Repair malformed LLM output
llm_output = 'Sure! <root><user name=john>Hello'
repaired = repair_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
print(repaired)
# Output: <root><user name="john">Hello</user></root>

# 2. Parse directly to a dictionary
data = parse_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
print(data)
# Output: {'root': {'user': {'@attributes': {'name': 'john'}, '#text': 'Hello'}}}
```

### üìö API Reference

| Function | Description | Key Arguments |
|----------|-------------|---------------|
| `repair_xml_safe` | Core function. Returns repaired XML string. | `xml_input`, `trust`, `format_output` |
| `parse_xml_safe` | Repairs and converts to Python dict. | `xml_input`, `trust` |
| `StreamingXMLRepair` | Context manager for streaming processing. | `trust` |
| `format_xml` | Utility to pretty-print or minify XML. | `xml_string`, `style` |

### Trust Levels

| Level | Use Case | Security Features |
|-------|----------|-------------------|
| `UNTRUSTED` | LLM output, user uploads | üîí Strict escaping, strips dangerous tags (script/iframe), prevents XXE & DoS. |
| `INTERNAL` | Internal microservices | üîê Balanced protection, higher depth limits. |
| `TRUSTED` | Hardcoded strings, tests | ‚ö° No overhead, fastest performance. |

## üåä Real-Time Streaming

For RAG pipelines and chat interfaces, you can repair XML **as it is being generated**, reducing latency to near zero. Xenon handles the chunking logic for you.

```python
from xenon.streaming import StreamingXMLRepair
from xenon import TrustLevel

# Works with any iterator (sync or async)
def llm_stream():
    yield "Here is the data:\n<use"
    yield "r id=1>Al"
    yield "ice</user>"

with StreamingXMLRepair(trust=TrustLevel.UNTRUSTED) as repairer:
    for chunk in llm_stream():
        # Yields safe, valid XML fragments immediately
        for safe_fragment in repairer.feed(chunk):
            print(safe_fragment, end="")

# Output: <user id="1">Alice</user>
```

## üîó Integrations

### LangChain
Xenon provides a drop-in `XenonXMLOutputParser` for LangChain pipelines.

```python
from xenon.integrations.langchain import XenonXMLOutputParser
from xenon import TrustLevel

# Create the parser
parser = XenonXMLOutputParser(
    trust=TrustLevel.UNTRUSTED,
    return_dict=True  # Returns dict, set False for string
)

# Use in your chain
chain = prompt | llm | parser
result = chain.invoke({"query": "Generate user XML"})
```

## üõ†Ô∏è Common Repair Scenarios

Xenon automatically handles the most common LLM failure modes:

**1. Truncation / Cut-off**
```python
# Input:  <root><list><item>Item 1
# Output: <root><list><item>Item 1</item></list></root>
```

**2. Conversational Fluff**
```python
# Input:  Here is the XML: <data>value</data> Hope that helps!
# Output: <data>value</data>
```

**3. Malformed Attributes**
```python
# Input:  <user name=john age=25>
# Output: <user name="john" age="25"></user>
```

**4. Unescaped Entities**
```python
# Input:  <text>Barnes & Noble</text>
# Output: <text>Barnes &amp; Noble</text>
```

**5. Hallucinated/Invalid Tags**
```python
# Input:  <123tag>data</123tag>
# Config: sanitize_invalid_tags=True
# Output: <tag_123tag>data</tag_123tag>
```

## üìä Analysis & Formatting

### Diff Reporting
See exactly what the repair engine changed.

```python
from xenon import repair_xml_with_report, TrustLevel

xml = "<root><item>test"
repaired, report = repair_xml_with_report(xml, trust=TrustLevel.UNTRUSTED)

print(report.summary())
# Performed 1 repair(s):
#   - [truncation] Added closing tags for: item, root
```

### Formatting
Pretty-print or minify your XML.

```python
from xenon import format_xml

xml = "<root><item>val</item></root>"
print(format_xml(xml, style="pretty"))
# <root>
#   <item>val</item>
# </root>
```

## Advanced Configuration

For specific needs, you can override security or repair settings individually:

```python
from xenon import repair_xml_safe, TrustLevel

repaired = repair_xml_safe(
    "<root><script>alert(1)</script></root>",
    trust=TrustLevel.UNTRUSTED,
    # Overrides:
    strip_dangerous_tags=False,  # Keep <script> tags (Use with caution!)
    format_output="pretty",      # Auto-format result
    schema_content=my_xsd_schema # Validate against XSD schema
)
```

### Audit Logging

For enterprise use cases requiring traceability (SOC 2, ISO 27001), Xenon can log security events:

```python
from xenon.audit import AuditLogger

# Configure logger
logger = AuditLogger()

# Usage
repair_xml_safe(
    untrusted_input,
    trust=TrustLevel.UNTRUSTED,
    audit_logger=logger
)

# Export logs
logs = logger.to_json()
# [
#   {
#     "timestamp": "2023-10-27T...",
#     "threats_detected": ["dangerous_pi"],
#     "actions_taken": ["DANGEROUS_PI_STRIPPED: Removed..."],
#     ...
#   }
# ]
```

## Interactive Demo

Try Xenon in your browser with our Google Colab notebook:

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/MarsZDF/xenon/blob/main/xenon_demo.ipynb)

## License

MIT License. See [LICENSE](LICENSE) for details.