"""
Xenon: A robust XML repair library for LLM-generated XML.

This library provides utilities to clean up and repair malformed XML that is
commonly generated by Large Language Models (LLMs), including handling:
- Truncation/Cut-off issues
- Conversational fluff around XML
- Malformed attributes
- Unescaped entities
- Pseudo-XML content
"""

from typing import Any, Dict, Optional, Tuple

from .config import RepairFlags, SecurityFlags, XMLRepairConfig
from .exceptions import MalformedXMLError, RepairError, ValidationError, XenonException
from .parser import XMLRepairEngine
from .preprocessor import XMLPreprocessor
from .reporting import RepairAction, RepairReport, RepairType
from .security import XMLSecurityFilter
from .validation import validate_repaired_output, validate_xml_input

__version__ = "0.5.0"
__author__ = "Xenon Contributors"

# Initialize the engine once for module-level functions
_engine = XMLRepairEngine()


def repair_xml(xml_string: str) -> str:
    """
    Repair malformed XML generated by LLMs.

    This function handles common LLM failure modes:
    - Truncation/cut-off (auto-closes open tags)
    - Conversational fluff (extracts XML from surrounding text)
    - Malformed attributes (adds missing quotes)
    - Unescaped entities (escapes & and < in text content)

    Args:
        xml_string (str): The potentially malformed XML string

    Returns:
        str: A well-formed XML string

    Example:
        >>> repair_xml('Sure, here is the XML: <root><user name=john')
        '<root><user name="john"></user></root>'
    """
    return _engine.repair_xml(xml_string)


def repair_xml_with_report(xml_string: str) -> Tuple[str, RepairReport]:
    """
    Repair malformed XML and get a detailed report of what was fixed.

    This function provides full transparency into what repairs were performed,
    making it easier to debug issues and understand LLM failure modes.

    Args:
        xml_string (str): The potentially malformed XML string

    Returns:
        tuple: (repaired_xml: str, report: RepairReport)

    Example:
        >>> xml = '<root><item attr=unquoted>text & more'
        >>> result, report = repair_xml_with_report(xml)
        >>> print(result)
        '<root><item attr="unquoted">text &amp; more</item></root>'
        >>> print(report.summary())
        Performed 3 repairs:
          - Added closing tags for truncation
          - Added quotes to attribute value
          - Escaped unescaped ampersand
        >>> print(f"Total repairs: {len(report)}")
        Total repairs: 3
    """
    # For now, create a basic report (we'll enhance XMLRepairEngine to populate this)
    report = RepairReport(
        original_xml=xml_string,
        repaired_xml=""  # Will be set after repair
    )

    # Perform repair
    repaired = _engine.repair_xml(xml_string)
    report.repaired_xml = repaired

    # Basic detection of what happened (simple heuristics for now)
    if len(repaired) > len(xml_string):
        # Likely added closing tags
        report.add_action(
            RepairType.TRUNCATION,
            "Added missing closing tags",
            location="end of document"
        )

    if xml_string != xml_string.strip() and repaired == xml_string.strip():
        # Whitespace trimmed
        pass

    if '&amp;' in repaired and '&amp;' not in xml_string:
        # Escaped entities
        report.add_action(
            RepairType.UNESCAPED_ENTITY,
            "Escaped unescaped ampersands in text content"
        )

    if 'name="' in repaired and 'name=' in xml_string and 'name="' not in xml_string:
        # Fixed attributes
        report.add_action(
            RepairType.MALFORMED_ATTRIBUTE,
            "Added quotes to unquoted attribute values"
        )

    if '<![CDATA[' in repaired and '<![CDATA[' not in xml_string:
        # Added CDATA
        report.add_action(
            RepairType.CDATA_WRAPPED,
            "Wrapped code content in CDATA section"
        )

    return repaired, report


def parse_xml(xml_string: str) -> Dict[str, Any]:
    """
    Repair malformed XML and convert it to a Python dictionary.

    This function first repairs the XML using repair_xml(), then converts
    the result to a nested dictionary structure.

    Args:
        xml_string (str): The potentially malformed XML string

    Returns:
        dict: A nested dictionary representation of the XML

    Example:
        >>> parse_xml('<root><user name="john">Hello</user></root>')
        {'root': {'user': {'@attributes': {'name': 'john'}, '#text': 'Hello'}}}
    """
    return _engine.xml_to_dict(xml_string)


def repair_xml_safe(
    xml_string: str,
    strict: bool = False,
    allow_empty: bool = False,
    max_size: Optional[int] = None,
    strip_dangerous_pis: bool = False,
    strip_external_entities: bool = False,
    strip_dangerous_tags: bool = False,
    wrap_multiple_roots: bool = False,
    sanitize_invalid_tags: bool = False,
    fix_namespace_syntax: bool = False
) -> str:
    """
    Safely repair XML with comprehensive error handling and validation.

    This function provides the same repair capabilities as repair_xml(), but with
    robust error handling and input validation. It's recommended for production use.

    Args:
        xml_string: The potentially malformed XML string to repair
        strict: If True, validate repaired output and raise MalformedXMLError
                if output still doesn't look like valid XML
        allow_empty: If True, accept empty/whitespace-only input (returns '')
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)
        strip_dangerous_pis: Strip processing instructions that look like code (php, asp, jsp).
                            Security feature to prevent code injection attacks.
        strip_external_entities: Strip external entity declarations (XXE prevention).
                                Removes DOCTYPE declarations that may contain SYSTEM/PUBLIC entities.
        strip_dangerous_tags: Strip potentially dangerous tags (script, iframe, object, embed).
                             Security feature to help prevent XSS attacks.
        wrap_multiple_roots: Wrap multiple root elements in synthetic <document> root.
                            Ensures valid XML 1.0 (which requires exactly one root element).
        sanitize_invalid_tags: Fix invalid XML tag names (e.g., <123> → <tag_123>, <tag name> → <tag_name>).
                              Ensures tag names comply with XML specification.
        fix_namespace_syntax: Fix invalid namespace syntax (e.g., <bad::ns> → <bad_ns>, <ns1:ns2:tag> → <ns1:ns2_tag>).
                             Ensures namespace syntax complies with XML specification.

    Returns:
        Repaired XML string

    Raises:
        ValidationError: If input is invalid (wrong type, empty when not allowed, etc.)
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs during repair

    Examples:
        >>> repair_xml_safe('<root><item')
        '<root><item></item></root>'

        >>> repair_xml_safe(None)
        ValidationError: Expected string input, got NoneType

        >>> repair_xml_safe('', allow_empty=True)
        ''

        >>> repair_xml_safe('<root>', strict=True)
        '<root></root>'
    """
    # Step 1: Validate input
    try:
        validate_xml_input(xml_string, allow_empty=allow_empty, max_size=max_size)
    except ValidationError:
        # Re-raise validation errors as-is with their helpful messages
        raise

    # Step 2: Handle empty case early (after validation passes)
    if not xml_string.strip():
        return ''

    # Step 3: Attempt repair with error handling
    try:
        # Use custom engine if any non-default features requested
        if strip_dangerous_pis or strip_external_entities or strip_dangerous_tags or wrap_multiple_roots or sanitize_invalid_tags or fix_namespace_syntax:
            custom_engine = XMLRepairEngine(
                strip_dangerous_pis=strip_dangerous_pis,
                strip_external_entities=strip_external_entities,
                strip_dangerous_tags=strip_dangerous_tags,
                wrap_multiple_roots=wrap_multiple_roots,
                sanitize_invalid_tags=sanitize_invalid_tags,
                fix_namespace_syntax=fix_namespace_syntax
            )
            result = custom_engine.repair_xml(xml_string)
        else:
            result = _engine.repair_xml(xml_string)

        # Step 4: Validate output if in strict mode
        if strict:
            validate_repaired_output(result, xml_string)

        return result

    except AttributeError as e:
        # Catch internal attribute errors (likely from None/unexpected values)
        raise RepairError(
            f"Internal error during repair: {e}. "
            f"This may indicate a bug in Xenon. Please report it."
        ) from e

    except IndexError as e:
        # Catch index errors from unexpected structure
        raise RepairError(
            f"Index error during parsing: {e}. "
            f"Input may contain unexpected structure."
        ) from e

    except (ValidationError, MalformedXMLError, RepairError):
        # Re-raise our own exceptions as-is
        raise

    except Exception as e:
        # Catch-all for unexpected errors
        raise RepairError(
            f"Unexpected error during repair: {type(e).__name__}: {e}"
        ) from e


def parse_xml_safe(
    xml_string: str,
    strict: bool = False,
    allow_empty: bool = False,
    max_size: Optional[int] = None
) -> Dict[str, Any]:
    """
    Safely parse malformed XML to dictionary with error handling.

    This function repairs the XML using repair_xml_safe(), then converts
    to a dictionary. Provides the same safety guarantees as repair_xml_safe().

    Args:
        xml_string: The potentially malformed XML string to parse
        strict: If True, validate repaired XML structure
        allow_empty: If True, accept empty input (returns {})
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)

    Returns:
        Dictionary representation of the XML

    Raises:
        ValidationError: If input is invalid
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs

    Examples:
        >>> parse_xml_safe('<root><item>test</item></root>')
        {'root': {'item': 'test'}}

        >>> parse_xml_safe('', allow_empty=True)
        {}

        >>> parse_xml_safe(None)
        ValidationError: Expected string input, got NoneType
    """
    # Use repair_xml_safe for validation and repair
    repaired = repair_xml_safe(
        xml_string,
        strict=strict,
        allow_empty=allow_empty,
        max_size=max_size
    )

    # Handle empty case
    if not repaired.strip():
        return {}

    # Convert to dictionary
    try:
        return _engine.xml_to_dict(repaired)
    except Exception as e:
        raise RepairError(
            f"Error converting XML to dictionary: {type(e).__name__}: {e}"
        ) from e


def repair_xml_lenient(xml_input: Any) -> str:
    """
    Repair XML in lenient mode - never raises exceptions.

    This function attempts to repair any input and always returns a string,
    even if the input is invalid (None, wrong type, etc.). Returns empty
    string on any error.

    This is useful when you want maximum fault tolerance and prefer an
    empty result over handling exceptions.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Repaired XML string, or empty string on any error

    Examples:
        >>> repair_xml_lenient(None)
        ''

        >>> repair_xml_lenient(123)
        ''

        >>> repair_xml_lenient(['<root>'])
        ''

        >>> repair_xml_lenient('<root><item')
        '<root><item></item></root>'

        >>> repair_xml_lenient('Just plain text')
        'Just plain text'
    """
    try:
        # Convert to string if not already
        if not isinstance(xml_input, str):
            if xml_input is None:
                return ''
            # Try to convert to string
            xml_input = str(xml_input)

        # Attempt repair
        return _engine.repair_xml(xml_input)

    except Exception:
        # Silently return empty string on any error
        return ''


def parse_xml_lenient(xml_input: Any) -> Dict[str, Any]:
    """
    Parse XML in lenient mode - never raises exceptions.

    This function attempts to parse any input and always returns a dict,
    even if the input is invalid. Returns empty dict on any error.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Dictionary representation, or empty dict on any error

    Examples:
        >>> parse_xml_lenient(None)
        {}

        >>> parse_xml_lenient('<root><item>test</item>')
        {'root': {'item': 'test'}}

        >>> parse_xml_lenient('invalid')
        {}
    """
    try:
        repaired = repair_xml_lenient(xml_input)
        if not repaired.strip():
            return {}
        return _engine.xml_to_dict(repaired)
    except Exception:
        return {}


# Public interface
__all__ = [
    # Core functions
    'repair_xml',
    'parse_xml',

    # Safe functions with error handling
    'repair_xml_safe',
    'parse_xml_safe',

    # Lenient functions (never raise)
    'repair_xml_lenient',
    'parse_xml_lenient',

    # Advanced features (v0.5.0+)
    'repair_xml_with_report',

    # Exceptions
    'XenonException',
    'ValidationError',
    'MalformedXMLError',
    'RepairError',

    # Advanced usage - Core engine
    'XMLRepairEngine',

    # Advanced usage - Configuration (v0.5.0+)
    'XMLRepairConfig',
    'SecurityFlags',
    'RepairFlags',

    # Advanced usage - Components (v0.5.0+)
    'XMLPreprocessor',
    'XMLSecurityFilter',

    # Advanced usage - Reporting (v0.5.0+)
    'RepairReport',
    'RepairAction',
    'RepairType',
]
