"""
Xenon: A robust XML repair library for LLM-generated XML.

This library provides utilities to clean up and repair malformed XML that is
commonly generated by Large Language Models (LLMs), including handling:
- Truncation/Cut-off issues
- Conversational fluff around XML
- Malformed attributes
- Unescaped entities
- Pseudo-XML content
"""

from .parser import XMLRepairEngine
from .exceptions import (
    XenonException,
    ValidationError,
    MalformedXMLError,
    RepairError
)
from .validation import validate_xml_input, validate_repaired_output

__version__ = "0.1.0"
__author__ = "Xenon Contributors"

# Initialize the engine once for module-level functions
_engine = XMLRepairEngine()


def repair_xml(xml_string: str) -> str:
    """
    Repair malformed XML generated by LLMs.
    
    This function handles common LLM failure modes:
    - Truncation/cut-off (auto-closes open tags)
    - Conversational fluff (extracts XML from surrounding text)
    - Malformed attributes (adds missing quotes)
    - Unescaped entities (escapes & and < in text content)
    
    Args:
        xml_string (str): The potentially malformed XML string
        
    Returns:
        str: A well-formed XML string
        
    Example:
        >>> repair_xml('Sure, here is the XML: <root><user name=john')
        '<root><user name="john"></user></root>'
    """
    return _engine.repair_xml(xml_string)


def parse_xml(xml_string: str) -> dict:
    """
    Repair malformed XML and convert it to a Python dictionary.
    
    This function first repairs the XML using repair_xml(), then converts
    the result to a nested dictionary structure.
    
    Args:
        xml_string (str): The potentially malformed XML string
        
    Returns:
        dict: A nested dictionary representation of the XML
        
    Example:
        >>> parse_xml('<root><user name="john">Hello</user></root>')
        {'root': {'user': {'@attributes': {'name': 'john'}, '#text': 'Hello'}}}
    """
    return _engine.xml_to_dict(xml_string)


def repair_xml_safe(
    xml_string: str,
    strict: bool = False,
    allow_empty: bool = False,
    max_size: int = None
) -> str:
    """
    Safely repair XML with comprehensive error handling and validation.

    This function provides the same repair capabilities as repair_xml(), but with
    robust error handling and input validation. It's recommended for production use.

    Args:
        xml_string: The potentially malformed XML string to repair
        strict: If True, validate repaired output and raise MalformedXMLError
                if output still doesn't look like valid XML
        allow_empty: If True, accept empty/whitespace-only input (returns '')
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)

    Returns:
        Repaired XML string

    Raises:
        ValidationError: If input is invalid (wrong type, empty when not allowed, etc.)
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs during repair

    Examples:
        >>> repair_xml_safe('<root><item')
        '<root><item></item></root>'

        >>> repair_xml_safe(None)
        ValidationError: Expected string input, got NoneType

        >>> repair_xml_safe('', allow_empty=True)
        ''

        >>> repair_xml_safe('<root>', strict=True)
        '<root></root>'
    """
    # Step 1: Validate input
    try:
        validate_xml_input(xml_string, allow_empty=allow_empty, max_size=max_size)
    except ValidationError:
        # Re-raise validation errors as-is with their helpful messages
        raise

    # Step 2: Handle empty case early (after validation passes)
    if not xml_string.strip():
        return ''

    # Step 3: Attempt repair with error handling
    try:
        result = _engine.repair_xml(xml_string)

        # Step 4: Validate output if in strict mode
        if strict:
            validate_repaired_output(result, xml_string)

        return result

    except AttributeError as e:
        # Catch internal attribute errors (likely from None/unexpected values)
        raise RepairError(
            f"Internal error during repair: {e}. "
            f"This may indicate a bug in Xenon. Please report it."
        ) from e

    except IndexError as e:
        # Catch index errors from unexpected structure
        raise RepairError(
            f"Index error during parsing: {e}. "
            f"Input may contain unexpected structure."
        ) from e

    except (ValidationError, MalformedXMLError, RepairError):
        # Re-raise our own exceptions as-is
        raise

    except Exception as e:
        # Catch-all for unexpected errors
        raise RepairError(
            f"Unexpected error during repair: {type(e).__name__}: {e}"
        ) from e


def parse_xml_safe(
    xml_string: str,
    strict: bool = False,
    allow_empty: bool = False,
    max_size: int = None
) -> dict:
    """
    Safely parse malformed XML to dictionary with error handling.

    This function repairs the XML using repair_xml_safe(), then converts
    to a dictionary. Provides the same safety guarantees as repair_xml_safe().

    Args:
        xml_string: The potentially malformed XML string to parse
        strict: If True, validate repaired XML structure
        allow_empty: If True, accept empty input (returns {})
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)

    Returns:
        Dictionary representation of the XML

    Raises:
        ValidationError: If input is invalid
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs

    Examples:
        >>> parse_xml_safe('<root><item>test</item></root>')
        {'root': {'item': 'test'}}

        >>> parse_xml_safe('', allow_empty=True)
        {}

        >>> parse_xml_safe(None)
        ValidationError: Expected string input, got NoneType
    """
    # Use repair_xml_safe for validation and repair
    repaired = repair_xml_safe(
        xml_string,
        strict=strict,
        allow_empty=allow_empty,
        max_size=max_size
    )

    # Handle empty case
    if not repaired.strip():
        return {}

    # Convert to dictionary
    try:
        return _engine.xml_to_dict(repaired)
    except Exception as e:
        raise RepairError(
            f"Error converting XML to dictionary: {type(e).__name__}: {e}"
        ) from e


def repair_xml_lenient(xml_input) -> str:
    """
    Repair XML in lenient mode - never raises exceptions.

    This function attempts to repair any input and always returns a string,
    even if the input is invalid (None, wrong type, etc.). Returns empty
    string on any error.

    This is useful when you want maximum fault tolerance and prefer an
    empty result over handling exceptions.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Repaired XML string, or empty string on any error

    Examples:
        >>> repair_xml_lenient(None)
        ''

        >>> repair_xml_lenient(123)
        ''

        >>> repair_xml_lenient(['<root>'])
        ''

        >>> repair_xml_lenient('<root><item')
        '<root><item></item></root>'

        >>> repair_xml_lenient('Just plain text')
        'Just plain text'
    """
    try:
        # Convert to string if not already
        if not isinstance(xml_input, str):
            if xml_input is None:
                return ''
            # Try to convert to string
            xml_input = str(xml_input)

        # Attempt repair
        return _engine.repair_xml(xml_input)

    except Exception:
        # Silently return empty string on any error
        return ''


def parse_xml_lenient(xml_input) -> dict:
    """
    Parse XML in lenient mode - never raises exceptions.

    This function attempts to parse any input and always returns a dict,
    even if the input is invalid. Returns empty dict on any error.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Dictionary representation, or empty dict on any error

    Examples:
        >>> parse_xml_lenient(None)
        {}

        >>> parse_xml_lenient('<root><item>test</item>')
        {'root': {'item': 'test'}}

        >>> parse_xml_lenient('invalid')
        {}
    """
    try:
        repaired = repair_xml_lenient(xml_input)
        if not repaired.strip():
            return {}
        return _engine.xml_to_dict(repaired)
    except Exception:
        return {}


# Public interface
__all__ = [
    # Core functions (existing)
    'repair_xml',
    'parse_xml',

    # Safe functions with error handling (new)
    'repair_xml_safe',
    'parse_xml_safe',

    # Lenient functions (never raise)
    'repair_xml_lenient',
    'parse_xml_lenient',

    # Exceptions
    'XenonException',
    'ValidationError',
    'MalformedXMLError',
    'RepairError',

    # Advanced usage
    'XMLRepairEngine',
]